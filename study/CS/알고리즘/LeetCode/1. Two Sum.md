
[Link](https://leetcode.com/problems/two-sum/description/?envType=problem-list-v2&envId=oizxjoit)

### 최종 알고리즘 설계 (Python)

1. **해시 맵(딕셔너리) 생성**: 숫자의 값과 그 값의 인덱스를 저장할 비어있는 딕셔너리(`num_map`)를 준비합니다. 이 딕셔너리는 이전에 탐색한 숫자를 O(1) 시간 복잡도로 조회하는 데 사용됩니다.
2. **배열 순회 및 짝 찾기**: 입력 배열 `nums`를 `for` 루프를 이용해 순회하며 각 숫자의 **인덱스(`i`) 와 값(`num`)** 을 확인합니다. 
	1. **짝꿍 계산:** 현재 숫자 `num`의 짝이 될 `complement = target - num` 값을 계산합니다. 
	2. **짝꿍 확인:** `complement`가 `num_map`에 이미 키로 존재하는지 확인합니다. 만약 존재한다면, 이는 짝을 찾았다는 의미입니다. `num_map`에 저장된 `complement`의 인덱스와 현재 숫자의 인덱스 `i`를 즉시 반환합니다. 
	3. **정보 기록:** `complement`가 `num_map`에 없다면, 현재 숫자 `num`과 인덱스 `i`를 `num_map`에 기록합니다. 이는 이후의 숫자들이 현재 숫자를 짝으로 찾을 수 있도록 하기 위함입니다.

### Python

```Python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        # 1. 숫자와 인덱스를 기록할 해시 맵(딕셔너리) 생성
        num_map = {}

        # 2. 배열을 순회하며 인덱스(i)와 값(num)을 확인
        for i, num in enumerate(nums):
            # a. 현재 숫자의 짝(complement) 계산
            complement = target - num

            # b. 짝이 해시 맵에 있는지 확인
            if complement in num_map:
                # 짝을 찾았으면, 짝의 인덱스와 현재 인덱스를 반환
                return [num_map[complement], i]

            # c. 짝이 없다면, 현재 숫자와 인덱스를 해시 맵에 기록
            num_map[num] = i
```