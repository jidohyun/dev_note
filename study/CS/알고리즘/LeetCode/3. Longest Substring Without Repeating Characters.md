	
[Link](https://leetcode.com/problems/longest-substring-without-repeating-characters/description/?envType=problem-list-v2&envId=oizxjoit)
### **올바른 접근법: 슬라이딩 윈도우 (Sliding Window)**

이 문제는 "슬라이딩 윈도우"라는 기법을 사용하는 대표적인 문제입니다.

1. 두 개의 포인터, `left`와 `right`를 사용해 '윈도우'를 만듭니다. 이 윈도우가 우리가 검사하는 '부분 문자열'이 됩니다.
2. `right` 포인터를 오른쪽으로 한 칸씩 이동시키면서 윈도우를 넓힙니다.
3. 윈도우에 새로운 문자를 추가할 때마다, 그 문자가 이미 윈도우 안에 있는지 확인합니다.
4. **만약 중복된 문자가 나타나면**, `left` 포인터를 오른쪽으로 이동시키면서 윈도우를 줄여나갑니다. 언제까지? 중복을 일으켰던 문자가 윈도우에서 빠져나갈 때까지.
5. 매 단계마다 중복이 없는 윈도우의 최대 길이를 기록합니다.

### **솔루션 코드 (Python)**

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        # 윈도우 안에 있는 문자를 저장할 집합(set)
        char_set = set()
        
        # 윈도우의 왼쪽 포인터
        left = 0
        
        # 가장 긴 길이를 저장할 변수
        max_len = 0
        
        # 윈도우의 오른쪽 포인터를 문자열 끝까지 이동
        for right in range(len(s)):
            # 1. right 포인터의 문자가 윈도우(char_set)에 이미 있다면
            while s[right] in char_set:
                # 2. 중복이 없어질 때까지 left 포인터를 오른쪽으로 이동시키며
                #    윈도우에서 문자를 제거한다.
                char_set.remove(s[left])
                left += 1
            
            # 3. 이제 중복이 없으므로, right 포인터의 문자를 윈도우에 추가한다.
            char_set.add(s[right])
            
            # 4. 현재 윈도우의 길이(right - left + 1)와 지금까지의 최대 길이를 비교해 갱신한다.
            max_len = max(max_len, right - left + 1)
            
        return max_len

```

### **코드 실행 과정 예시 (`s = "abcabcbb"`)**

1. `right = 0`, `s[0] = 'a'`: `char_set`에 'a' 추가. `max_len = 1`. (`char_set = {'a'}, left = 0`)
2. `right = 1`, `s[1] = 'b'`: `char_set`에 'b' 추가. `max_len = 2`. (`char_set = {'a', 'b'}, left = 0`)
3. `right = 2`, `s[2] = 'c'`: `char_set`에 'c' 추가. `max_len = 3`. (`char_set = {'a', 'b', 'c'}, left = 0`)
4. `right = 3`, `s[3] = 'a'`: **'a'가 `char_set`에 이미 있음!**
    - `while` 루프 시작: `s[left]`('a')를 `char_set`에서 제거. `left`는 1이 됨. (`char_set = {'b', 'c'}`)
    - `while` 루프 종료 (이제 `s[3]`('a')가 `char_set`에 없음)
    - `char_set`에 'a' 추가. (`char_set = {'b', 'c', 'a'}`)
    - 현재 길이 `3 - 1 + 1 = 3`. `max_len`은 여전히 3.
5. ... 위 과정을 문자열 끝까지 반복합니다.

최종적으로 가장 길었던 길이인 **3**이 반환됩니다.