
---
#### 버블정렬?

- 기본적인 개념은 서로 **인접한** 두 원소를 검사하여 정렬하는 알고리즘이다.
- 오름차순으로 정렬한다.

버블정렬은 첫번째 자료와 두번째 자료를, 두번째 자료와 세번째 자료를... 이런식으로 쭉 비교해서
마지막 자료와 (마지막 - 1)의 자료까지 비교하여 교환하면서 자료를 정렬한다.

1회전을 수행하고나면 가장 큰 자료가 마지막으로 정렬되고 가장 큰 자료는 정렬에서 제외된다.
2회전이 끝나면 위와같이 가장 큰 자료가 이미 정렬된 자료를 제외하고 가장 큰 자료로 정렬된다.
이렇게 1회전이 끝날때마다 오름차순으로 하나씩 정렬되는 형태이다.

#### 예제

![[스크린샷 2024-08-09 오후 6.14.27 복사본.png]]

위는 7, 4, 5, 1, 3의 초기상태인 배열을 버블정렬 오름차순으로 정렬하는 과정이다.
회전별로 설명해보겠다.

- 1회전
	- 첫번째 인덱스에 들어있는 데이터를 다음 인덱스와 하나씩 비교하며 가다가 마지막 인덱스에 도달해서 정렬이 된다.
- 2회전
	- 1회전과 마찬가지로 첫번째 인덱스에 들어있는 데이터를 다음 인덱스와 쭉 비교한다, 비교하다가 자신보다 큰 데이터를 만나니까 비교하는 데이터가 큰 데이터로 바뀐다. 그리고 쭉 비교하고 이미 정렬된 데이터를 제외하고 제일 큰 데이터로 정렬된다.
- 3회전
	- 앞에 회전들을 또 반복한다. 맨 앞 데이터를 그 다음 데이터들과 쭉 비교하고 정렬이 된다.
- 정렬완료
	- 계속 반복하여 4회전만에 정렬을 끝냈다.

#### 버블정렬 주요 c코드

```c
void bubbleSort(int* arr){
    int i,j, temp;
    for(i=0; i < LEN; i++){
        for(j=0; j<LEN-i-1; j++){
            if(arr[j] > arr[j+1]){    // swap
                temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
}
```

### 버블정렬 장점

- 구현이 간단
- in place 알고리즘이기 때문에 메모리가 절약된다.

### 버블정렬 단점

- 최선이든 최악이든 시간복잡도가 오래걸린다.
- 원소의 개수가 많아지면 비교 횟수가 많아진다.



