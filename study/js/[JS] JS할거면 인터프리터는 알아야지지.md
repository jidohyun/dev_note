

---

### JS는 인터프리터 언어? 컴파일러 언어?

JS가 인터프리터 언어인지 컴파일러 언어인지에 대한 논쟁은 아주 오랫동안 이어졌다.
이에 대한 중론은 '스크립트 언어이다'지만 실상은 더 복잡하다.

프로그래밍 언어 발전사에서 인터프리터 언어와 스크립트 언어는 컴파일 언어에 비해 열악하다고 평가받아왔다. 성능 최적화가 잘 안된다는 인식과 더불어 일부 스크립트 언어에서 좀 더 성숙한 방식인 동적 타입 대신 정적 타입을 사용한는 등의 이유 때문이다.

컴파일을 거치면 보통 분산 시스템에서 언제든 배포할 수 있는 **바이너리 파일**이 생성된다. 
그런데 **JS는 소스 코드 자체를 배포하지, 바이너리 파일을 배포하는 게 아니기 때문에** 많은 사람이 JS는 컴파일러 언어가 아니라고 주장한다. 

실무에서 프로그램을 배포하는 형태와 관련된 방식은 수십 년에 걸쳐 아주 다양한 형태로 발전해왔다. 
인터프리터 언어인지 컴파일러 언어인지에 따라 배포 방식이 달라지는데, 오늘날에는 배포 방식이 더 이상 중요하지 않다고 주장하는 이들이 늘고 있다.

스크립트 언어나 인터프리터 언어는 대개 위에서 아래로 한 줄씩 코드가 실행되는 방식으로 만들어진다. 그리고 보통 실행이 시작되기 전에 거치는 사전 단계가 없다.


![](https://i.imgur.com/Oyj683G.png)
(인터프리터, 스크립트 언어의 실행 절차)

만약 인터프리터나 스크립트 언어로 작성한 프로그램의 다섯 번째 줄에 오류가 있다면 네 번째 줄이 실행되기 전까지는 오류를 발견하지 못한다.
그런데 오류는 부적합한 값이 할당된 변수, 값 같은 런타임 조건 때문일 수도 있고, 잘못된 문이나 명령 때문일 수도 있다. 상황에 따라 오류가 있는 줄이 실행될 때까지 오류 처리를 미루는 작업이 괜찮을 수도 있고 괜찮지 않을 수도 있다.

한편 프로그램이 실행되기 전에 파싱을 거치는 언어도 있다
위 그림과 아래 그림에서 본 인터프리터, 스크립트 언어의 실행 절차를 비교해보면,

![](https://i.imgur.com/0tIkhyH.png)
(파싱 + 컴파일 + 실행)

이렇게 파싱과 컴파일을 거치는 언어의 다섯 번째 줄에 유효하지 않은 명령이 있다면 파싱 단계에서 오류가 발견되므로 사전에 오류를 차단할 수 있다. 굳이 실행까지 하지 않아도 **파싱이 되지 않아** 프로그램을 실행할 수 없기 때문이다.

이렇게 실행 전에 오류가 포함된 코드 조각이 어디 있는지 알 수 있으면 구문 오류(혹은 정적 오류)를 차단하기 좋다.

그렇다면 파싱을 거치는 언어와 컴파일을 거치는 언어에는 어떤 공통점이 있을까? 첫 번째는 모든 컴파일 언어가 파싱을 거친다는 점이다. 파싱이 끝나면 언젠가는 컴파일이 진행될 거라고 예상할 수 있다. 고전 컴파일러 이론에선 파싱 이후의 절차 중 마지막 단계에서 실행 가능한 형태의 코드가 만들어진다.

파싱이 완전히 끝난 다음엔 파싱 결과인 AST(추상 구문 트리)를 컴퓨터가 실행할 수 있는 형태로 바꿔주는 작업이 이어진다. 파싱을 거치는 언어는 파싱에서 끝나는 게 아니라 실행 가능한 코드를 생성하는 작업까지 수행한다.