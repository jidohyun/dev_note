---
title: "2026년 코딩테스트 준비, 딱 정해드립니다."
source: "https://www.youtube.com/watch?v=iWJUA78Fb8c"
created: 2026-01-06T20:14:29.317+09:00
type: youtube
tags: [reading, summary]
---

# 핵심 요약
- 출제 빈도가 가장 높은 1순위 유형(시뮬레이션, 구현, 완전 탐색, BFS/DFS)을 최우선으로 완벽하게 마스터해야 합니다.
- 알고리즘의 동작 원리를 넘어 '이 기술을 어떤 상황에 써먹을지' 활용 목적(네트워크 개수, 연결 여부 등)을 파악하는 것이 중요합니다.
- 시험장에서는 고민 없이 바로 나올 수 있도록 주요 구현 패턴(인접 리스트 변환, 자료구조별 DFS/BFS 등)을 암기하고 변형 연습을 해야 합니다.
- 문제의 제약 조건을 보고 시간 복잡도를 계산하여(1초당 약 10^8번 연산) 적절한 알고리즘을 선택하는 능력을 길러야 합니다.

# 상세 내용
- 학습 우선순위 및 자료구조
  - 1순위: 시뮬레이션, 구현, 완전 탐색, BFS, DFS. 이를 위해 스택, 큐, 링크드리스트, 해시테이블, 그래프 등 기초 자료구조 학습이 선행되어야 합니다.
  - 2순위: DP, 다익스트라 등. 1순위 개념이 탄탄해야 2순위 알고리즘도 자연스럽게 이해할 수 있습니다.

- DFS와 BFS의 본질과 활용
  - 공통점: 그래프 순회(시작 노드와 연결된 모든 노드를 방문하는 것).
  - 활용 목적: 네트워크(컴포넌트)의 개수 파악, 특정 네트워크 내 요소의 개수 세기, 두 노드 간의 연결 여부 확인.
  - 확장: 격자(Grid) 형태의 문제도 그래프로 해석하여 동일한 순회 로직을 적용할 수 있습니다.

- 구현 패턴의 중요성
  - 인접 리스트 변환: 간선 리스트 정보를 인접 리스트로 바꾸는 코드는 생각하지 않고도 짤 수 있어야 합니다.
  - 데이터 구조의 변형: 노드 번호가 순차적이지 않거나 문자열인 경우, 배열 대신 해시맵(Hash Map)이나 해시셋(Hash Set)을 사용하여 방문 처리를 할 수 있어야 합니다.
  - 방향성 처리: 문제 조건에 따라 단방향 혹은 양방향 간선 처리를 유연하게 적용해야 합니다.
  - 전역 변수 관리: 방문 배열을 전역 변수로 쓸 경우, 새로운 탐색 시작 전 반드시 초기화(clear) 과정을 거쳐야 합니다.

- 시간 복잡도 기반의 문제 접근
  - 제약 조건 확인: N의 크기에 따라 O(N^2)이 가능한지, O(N log N)이나 O(N)으로 풀어야 하는지 결정됩니다.
  - 효율성 테스트: 최적의 방법이 떠오르지 않는다면, 일단 정확성이라도 맞출 수 있는 알고리즘으로 부분 점수를 노리는 전략이 필요합니다.

# 인사이트 / 할 일
- '이 알고리즘을 어디에 써먹을 수 있을까?'라는 질문을 스스로에게 계속 던지며 공부하기.
- 문제 풀이 시 30분 동안 고민해도 실마리가 보이지 않으면 해설을 보고 패턴을 이해한 뒤 암기하기.
- 한 문제를 풀더라도 자료구조를 바꿔보거나(배열 vs 해시), 조건을 변형(단방향 vs 양방향)하며 연습하기.
- 자주 쓰이는 구현 코드(인접 리스트 생성, DFS/BFS 기본 틀)는 시험장에서 바로 출력할 수 있도록 숙달하기.